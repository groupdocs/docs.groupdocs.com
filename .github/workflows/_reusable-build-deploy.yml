# Reusable workflow: build Hugo site (optionally with product docs) and deploy.
# Called by publish-site.yml and publish-assets.yml.
name: _reusable-build-deploy

on:
  workflow_call:
    inputs:
      base_url:
        description: 'Base URL override (empty = use config default)'
        type: string
        default: ''
      all_products:
        type: boolean
        default: false
      annotation:
        type: boolean
        default: false
      assembly:
        type: boolean
        default: false
      classification:
        type: boolean
        default: false
      comparison:
        type: boolean
        default: false
      conversion:
        type: boolean
        default: false
      editor:
        type: boolean
        default: false
      markdown:
        type: boolean
        default: false
      merger:
        type: boolean
        default: false
      metadata:
        type: boolean
        default: false
      parser:
        type: boolean
        default: false
      redaction:
        type: boolean
        default: false
      search:
        type: boolean
        default: false
      signature:
        type: boolean
        default: false
      total:
        type: boolean
        default: false
      viewer:
        type: boolean
        default: false
      watermark:
        type: boolean
        default: false
    secrets:
      DOCS_SSH_HOST:
        required: true
      DEPLOY_SSH_DIR:
        required: true
      DOCS_SSH_USER:
        required: true
      DOCS_SSH_KEY:
        required: true

jobs:

  build:
    runs-on: self-hosted

    steps:
      - uses: actions/checkout@v4

      - name: Install Hugo
        run: |
          curl -LO https://github.com/gohugoio/hugo/releases/download/v0.101.0/hugo_extended_0.101.0_Linux-64bit.deb
          sudo dpkg -i hugo_extended_0.101.0_Linux-64bit.deb

      - name: Download product documentation
        if: >-
          ${{
            inputs.all_products ||
            inputs.annotation || inputs.assembly || inputs.classification ||
            inputs.comparison || inputs.conversion || inputs.editor ||
            inputs.markdown || inputs.merger || inputs.metadata ||
            inputs.parser || inputs.redaction || inputs.search ||
            inputs.signature || inputs.total || inputs.viewer || inputs.watermark
          }}
        run: |
          # Full product registry: "key:Name"
          ALL_PRODUCTS="
            annotation:Annotation
            assembly:Assembly
            classification:Classification
            comparison:Comparison
            conversion:Conversion
            editor:Editor
            markdown:Markdown
            merger:Merger
            metadata:Metadata
            parser:Parser
            redaction:Redaction
            search:Search
            signature:Signature
            total:Total
            viewer:Viewer
            watermark:Watermark
          "

          # Build the list of products to download
          if [[ "${{ inputs.all_products }}" == "true" ]]; then
            PRODUCTS="$ALL_PRODUCTS"
            echo "Mode: all products"
          else
            PRODUCTS=""
            for entry in $ALL_PRODUCTS; do
              key="${entry%%:*}"
              case "$key" in
                annotation)     [[ "${{ inputs.annotation }}"     == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                assembly)       [[ "${{ inputs.assembly }}"       == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                classification) [[ "${{ inputs.classification }}" == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                comparison)     [[ "${{ inputs.comparison }}"     == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                conversion)     [[ "${{ inputs.conversion }}"     == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                editor)         [[ "${{ inputs.editor }}"         == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                markdown)       [[ "${{ inputs.markdown }}"       == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                merger)         [[ "${{ inputs.merger }}"         == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                metadata)       [[ "${{ inputs.metadata }}"       == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                parser)         [[ "${{ inputs.parser }}"         == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                redaction)      [[ "${{ inputs.redaction }}"      == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                search)         [[ "${{ inputs.search }}"         == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                signature)      [[ "${{ inputs.signature }}"      == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                total)          [[ "${{ inputs.total }}"          == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                viewer)         [[ "${{ inputs.viewer }}"         == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
                watermark)      [[ "${{ inputs.watermark }}"      == "true" ]] && PRODUCTS="$PRODUCTS $entry" ;;
              esac
            done
            echo "Mode: selected products"
          fi

          echo "Products to download: $PRODUCTS"

          for entry in $PRODUCTS; do
            product="${entry%%:*}"
            product_name="${entry##*:}"
            repo_url="https://github.com/groupdocs-${product}/GroupDocs.${product_name}-Docs.git"

            echo "::group::Downloading ${product} documentation"
            echo "Repository: groupdocs-${product}/GroupDocs.${product_name}-Docs"

            git clone --depth 1 "${repo_url}" "temp-${product}" 2>&1 || {
              echo "::warning::Failed to clone GroupDocs.${product_name}-Docs"
              echo "::endgroup::"
              continue
            }

            # Create content directory for this product
            mkdir -p "content/${product}"

            # Copy product family index page
            if [ -f "temp-${product}/_index.md" ]; then
              cp "temp-${product}/_index.md" "content/${product}/"
              echo "Copied _index.md"
            fi

            # Copy platform-specific documentation folders
            for platform in net java nodejs-java python-net; do
              if [ -d "temp-${product}/${platform}" ]; then
                cp -r "temp-${product}/${platform}" "content/${product}/"
                echo "Copied ${platform}/ folder"
              fi
            done

            # Cleanup cloned repo
            rm -rf "temp-${product}"
            echo "::endgroup::"
          done

          echo ""
          echo "=== Content structure ==="
          ls -la content/

      - name: Build site
        run: |
          HUGO_ARGS="--minify"
          if [ -n "${{ inputs.base_url }}" ]; then
            HUGO_ARGS="$HUGO_ARGS --baseURL '${{ inputs.base_url }}'"
          fi
          eval hugo $HUGO_ARGS

      - name: Move MD files to ugly URLs
        run: ./move_md_to_ugly_urls.sh

      - name: Remove index.json (published separately by publish-assets workflow)
        if: ${{ !inputs.all_products }}
        run: rm -f ./public/index.json

      - name: Remove llms.txt (incomplete on partial builds)
        if: ${{ !inputs.all_products }}
        run: rm -f ./public/llms.txt

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DOCS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DOCS_SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy artifacts
        run: |
          SSH_OPTS="-i ~/.ssh/deploy_key -o ServerAliveInterval=60 -o ServerAliveCountMax=30"
          RSYNC_OPTS="-vrOt --inplace --chmod=D755,F644 --timeout=300"
          REMOTE="${{ secrets.DOCS_SSH_USER }}@${{ secrets.DOCS_SSH_HOST }}:${{ secrets.DEPLOY_SSH_DIR }}"

          if [[ "${{ inputs.all_products }}" == "true" ]]; then
            # Full build: sync everything, remove stale files
            rsync $RSYNC_OPTS --delete -e "ssh $SSH_OPTS" public/ "$REMOTE"
          else
            # Partial build: update root-level files without deleting anything
            rsync $RSYNC_OPTS -e "ssh $SSH_OPTS" public/ "$REMOTE"

            # Then clean up stale files within each built product directory
            KNOWN_PRODUCTS="annotation assembly classification comparison conversion editor markdown merger metadata parser redaction search signature total viewer watermark"
            for product in $KNOWN_PRODUCTS; do
              if [ -d "public/$product" ]; then
                echo "Cleaning up stale files in $product/"
                rsync $RSYNC_OPTS --delete -e "ssh $SSH_OPTS" "public/$product/" "$REMOTE/$product/"
              fi
            done
          fi

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key
